<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modern C++ based Kafka API: KAFKA_API::KafkaConsumer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Modern C++ based Kafka API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>KAFKA_API</b></li><li class="navelem"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html">KafkaConsumer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classKAFKA__API_1_1KafkaConsumer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KAFKA_API::KafkaConsumer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The base class for <a class="el" href="classKAFKA__API_1_1KafkaAutoCommitConsumer.html" title="Automatic-Commit consumer.">KafkaAutoCommitConsumer</a> and <a class="el" href="classKAFKA__API_1_1KafkaManualCommitConsumer.html" title="Manual-Commit consumer.">KafkaManualCommitConsumer</a>.  
 <a href="classKAFKA__API_1_1KafkaConsumer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="KafkaConsumer_8h_source.html">KafkaConsumer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for KAFKA_API::KafkaConsumer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classKAFKA__API_1_1KafkaConsumer.png" usemap="#KAFKA_5FAPI::KafkaConsumer_map" alt=""/>
  <map id="KAFKA_5FAPI::KafkaConsumer_map" name="KAFKA_5FAPI::KafkaConsumer_map">
<area href="classKAFKA__API_1_1KafkaClient.html" title="The base class for Kafka clients (i.e, KafkaConsumer, KafkaProducer, and AdminClient)." alt="KAFKA_API::KafkaClient" shape="rect" coords="134,0,392,24"/>
<area href="classKAFKA__API_1_1KafkaAutoCommitConsumer.html" title="Automatic-Commit consumer." alt="KAFKA_API::KafkaAutoCommitConsumer" shape="rect" coords="0,112,258,136"/>
<area href="classKAFKA__API_1_1KafkaManualCommitConsumer.html" title="Manual-Commit consumer." alt="KAFKA_API::KafkaManualCommitConsumer" shape="rect" coords="268,112,526,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a579d4bd53c624ba64204f9ae110e0739"><td class="memItemLeft" align="right" valign="top"><a id="a579d4bd53c624ba64204f9ae110e0739"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a579d4bd53c624ba64204f9ae110e0739">getGroupId</a> () const</td></tr>
<tr class="memdesc:a579d4bd53c624ba64204f9ae110e0739"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get group ID. <br /></td></tr>
<tr class="separator:a579d4bd53c624ba64204f9ae110e0739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29bf8f7f04b19fb67458f1bfa6336a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af29bf8f7f04b19fb67458f1bfa6336a1">setGroupId</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:af29bf8f7f04b19fb67458f1bfa6336a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">To set group ID.  <a href="classKAFKA__API_1_1KafkaConsumer.html#af29bf8f7f04b19fb67458f1bfa6336a1">More...</a><br /></td></tr>
<tr class="separator:af29bf8f7f04b19fb67458f1bfa6336a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70f4ce12e2fa5fee7b07ace913eb1b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#aa70f4ce12e2fa5fee7b07ace913eb1b3">subscribe</a> (const Topics &amp;topics, Consumer::RebalanceCallback cb=Consumer::RebalanceCallback())</td></tr>
<tr class="memdesc:aa70f4ce12e2fa5fee7b07ace913eb1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to the given list of topics to get dynamically assigned partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#aa70f4ce12e2fa5fee7b07ace913eb1b3">More...</a><br /></td></tr>
<tr class="separator:aa70f4ce12e2fa5fee7b07ace913eb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaed194ba66df8a4e57354a7c784db55"><td class="memItemLeft" align="right" valign="top"><a id="adaed194ba66df8a4e57354a7c784db55"></a>
Topics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#adaed194ba66df8a4e57354a7c784db55">subscription</a> () const</td></tr>
<tr class="memdesc:adaed194ba66df8a4e57354a7c784db55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current subscription. <br /></td></tr>
<tr class="separator:adaed194ba66df8a4e57354a7c784db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd9af9255f51ec89d5ab3474c00d917"><td class="memItemLeft" align="right" valign="top"><a id="aecd9af9255f51ec89d5ab3474c00d917"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#aecd9af9255f51ec89d5ab3474c00d917">unsubscribe</a> ()</td></tr>
<tr class="memdesc:aecd9af9255f51ec89d5ab3474c00d917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe from topics currently subscribed. <br /></td></tr>
<tr class="separator:aecd9af9255f51ec89d5ab3474c00d917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59ed5d3f932dc969a65850728e18121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#ab59ed5d3f932dc969a65850728e18121">assign</a> (const TopicPartitions &amp;tps)</td></tr>
<tr class="memdesc:ab59ed5d3f932dc969a65850728e18121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assign a list of partitions to this consumer.  <a href="classKAFKA__API_1_1KafkaConsumer.html#ab59ed5d3f932dc969a65850728e18121">More...</a><br /></td></tr>
<tr class="separator:ab59ed5d3f932dc969a65850728e18121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab191206d025cf4b6167397d71400c6"><td class="memItemLeft" align="right" valign="top"><a id="a5ab191206d025cf4b6167397d71400c6"></a>
TopicPartitions&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a5ab191206d025cf4b6167397d71400c6">assignment</a> () const</td></tr>
<tr class="memdesc:a5ab191206d025cf4b6167397d71400c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of partitions currently assigned to this consumer. <br /></td></tr>
<tr class="separator:a5ab191206d025cf4b6167397d71400c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6674ebc4fcf57cbac3a9ab9842b7e916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a6674ebc4fcf57cbac3a9ab9842b7e916">seek</a> (const TopicPartition &amp;tp, Offset o, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="memdesc:a6674ebc4fcf57cbac3a9ab9842b7e916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the fetch offsets that the consumer will use on the next poll(timeout).  <a href="classKAFKA__API_1_1KafkaConsumer.html#a6674ebc4fcf57cbac3a9ab9842b7e916">More...</a><br /></td></tr>
<tr class="separator:a6674ebc4fcf57cbac3a9ab9842b7e916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc05b7d4f95e37099e12fb5d3593a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abfc05b7d4f95e37099e12fb5d3593a9d">seekToBeginning</a> (const TopicPartitions &amp;tps, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="memdesc:abfc05b7d4f95e37099e12fb5d3593a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to the first offset for each of the given partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#abfc05b7d4f95e37099e12fb5d3593a9d">More...</a><br /></td></tr>
<tr class="separator:abfc05b7d4f95e37099e12fb5d3593a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a21de0e7569ba32fac94faa53fccec4"><td class="memItemLeft" align="right" valign="top"><a id="a4a21de0e7569ba32fac94faa53fccec4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>seekToBeginning</b> (std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="separator:a4a21de0e7569ba32fac94faa53fccec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d399ab22eb97449a685f2ff6b870bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a7d399ab22eb97449a685f2ff6b870bdf">seekToEnd</a> (const TopicPartitions &amp;tps, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="memdesc:a7d399ab22eb97449a685f2ff6b870bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to the last offset for each of the given partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#a7d399ab22eb97449a685f2ff6b870bdf">More...</a><br /></td></tr>
<tr class="separator:a7d399ab22eb97449a685f2ff6b870bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11f1884a81e6c663f9313d1e71b5928"><td class="memItemLeft" align="right" valign="top"><a id="ad11f1884a81e6c663f9313d1e71b5928"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>seekToEnd</b> (std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="separator:ad11f1884a81e6c663f9313d1e71b5928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116faa8b6e7ef28d2fdcdad2f787f29e"><td class="memItemLeft" align="right" valign="top"><a id="a116faa8b6e7ef28d2fdcdad2f787f29e"></a>
Offset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a116faa8b6e7ef28d2fdcdad2f787f29e">position</a> (const TopicPartition &amp;tp) const</td></tr>
<tr class="memdesc:a116faa8b6e7ef28d2fdcdad2f787f29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset of the next record that will be fetched (if a record with that offset exists). <br /></td></tr>
<tr class="separator:a116faa8b6e7ef28d2fdcdad2f787f29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7682cac64a49e7f0f26d9b8f27ce8e"><td class="memItemLeft" align="right" valign="top">std::map&lt; TopicPartition, Offset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abc7682cac64a49e7f0f26d9b8f27ce8e">beginningOffsets</a> (const TopicPartitions &amp;tps) const</td></tr>
<tr class="memdesc:abc7682cac64a49e7f0f26d9b8f27ce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first offset for the given partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#abc7682cac64a49e7f0f26d9b8f27ce8e">More...</a><br /></td></tr>
<tr class="separator:abc7682cac64a49e7f0f26d9b8f27ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124721b254ba152f54d30b759f2509b6"><td class="memItemLeft" align="right" valign="top">std::map&lt; TopicPartition, Offset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a124721b254ba152f54d30b759f2509b6">endOffsets</a> (const TopicPartitions &amp;tps) const</td></tr>
<tr class="memdesc:a124721b254ba152f54d30b759f2509b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last offset for the given partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#a124721b254ba152f54d30b759f2509b6">More...</a><br /></td></tr>
<tr class="separator:a124721b254ba152f54d30b759f2509b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f7285339e8db1bdf65890627c7e041"><td class="memItemLeft" align="right" valign="top">std::map&lt; TopicPartition, Offset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#ad4f7285339e8db1bdf65890627c7e041">offsetsForTime</a> (const TopicPartitions &amp;tps, std::chrono::time_point&lt; std::chrono::system_clock &gt; timepoint, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_QUERY_TIMEOUT_MS)) const</td></tr>
<tr class="memdesc:ad4f7285339e8db1bdf65890627c7e041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offsets for the given partitions by time-point.  <a href="classKAFKA__API_1_1KafkaConsumer.html#ad4f7285339e8db1bdf65890627c7e041">More...</a><br /></td></tr>
<tr class="separator:ad4f7285339e8db1bdf65890627c7e041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14609c04b0bfd9df0f19cfef24428829"><td class="memItemLeft" align="right" valign="top">Offset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a14609c04b0bfd9df0f19cfef24428829">committed</a> (const TopicPartition &amp;tp)</td></tr>
<tr class="memdesc:a14609c04b0bfd9df0f19cfef24428829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last committed offset for the given partition (whether the commit happened by this process or another).This offset will be used as the position for the consumer in the event of a failure.  <a href="classKAFKA__API_1_1KafkaConsumer.html#a14609c04b0bfd9df0f19cfef24428829">More...</a><br /></td></tr>
<tr class="separator:a14609c04b0bfd9df0f19cfef24428829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cf4c8f017064009d960c3a7a414ff6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classKAFKA__API_1_1ConsumerRecord.html">ConsumerRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6">poll</a> (std::chrono::milliseconds timeout)</td></tr>
<tr class="memdesc:af2cf4c8f017064009d960c3a7a414ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.  <a href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6">More...</a><br /></td></tr>
<tr class="separator:af2cf4c8f017064009d960c3a7a414ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05de75ea64ca1b706c4d48674cfb450c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a05de75ea64ca1b706c4d48674cfb450c">poll</a> (std::chrono::milliseconds timeout, std::vector&lt; <a class="el" href="classKAFKA__API_1_1ConsumerRecord.html">ConsumerRecord</a> &gt; &amp;output)</td></tr>
<tr class="memdesc:a05de75ea64ca1b706c4d48674cfb450c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.  <a href="classKAFKA__API_1_1KafkaConsumer.html#a05de75ea64ca1b706c4d48674cfb450c">More...</a><br /></td></tr>
<tr class="separator:a05de75ea64ca1b706c4d48674cfb450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcffc0a2eb517a1c2ac6aef7dd468ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#afcffc0a2eb517a1c2ac6aef7dd468ac3">pause</a> (const TopicPartitions &amp;tps)</td></tr>
<tr class="memdesc:afcffc0a2eb517a1c2ac6aef7dd468ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend fetching from the requested partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#afcffc0a2eb517a1c2ac6aef7dd468ac3">More...</a><br /></td></tr>
<tr class="separator:afcffc0a2eb517a1c2ac6aef7dd468ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda00953ed830f8cd2a59ba1d9791036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abda00953ed830f8cd2a59ba1d9791036">pause</a> ()</td></tr>
<tr class="memdesc:abda00953ed830f8cd2a59ba1d9791036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend fetching from all assigned partitions.  <a href="classKAFKA__API_1_1KafkaConsumer.html#abda00953ed830f8cd2a59ba1d9791036">More...</a><br /></td></tr>
<tr class="separator:abda00953ed830f8cd2a59ba1d9791036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929031b982dd494a7e2b1ed2252709e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a929031b982dd494a7e2b1ed2252709e0">resume</a> (const TopicPartitions &amp;tps)</td></tr>
<tr class="memdesc:a929031b982dd494a7e2b1ed2252709e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume specified partitions which have been paused with <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abda00953ed830f8cd2a59ba1d9791036" title="Suspend fetching from all assigned partitions.">pause()</a>.  <a href="classKAFKA__API_1_1KafkaConsumer.html#a929031b982dd494a7e2b1ed2252709e0">More...</a><br /></td></tr>
<tr class="separator:a929031b982dd494a7e2b1ed2252709e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae365a263305dc74ffec2b4aed89aac59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#ae365a263305dc74ffec2b4aed89aac59">resume</a> ()</td></tr>
<tr class="memdesc:ae365a263305dc74ffec2b4aed89aac59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume all partitions which have been paused with <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abda00953ed830f8cd2a59ba1d9791036" title="Suspend fetching from all assigned partitions.">pause()</a>.  <a href="classKAFKA__API_1_1KafkaConsumer.html#ae365a263305dc74ffec2b4aed89aac59">More...</a><br /></td></tr>
<tr class="separator:ae365a263305dc74ffec2b4aed89aac59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afd47c7fa5df32b1690d67ae4352a4d"><td class="memItemLeft" align="right" valign="top"><a id="a0afd47c7fa5df32b1690d67ae4352a4d"></a>
<a class="el" href="classKAFKA__API_1_1Consumer_1_1ConsumerGroupMetadata.html">Consumer::ConsumerGroupMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#a0afd47c7fa5df32b1690d67ae4352a4d">groupMetadata</a> ()</td></tr>
<tr class="memdesc:a0afd47c7fa5df32b1690d67ae4352a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current group metadata associated with this consumer. <br /></td></tr>
<tr class="separator:a0afd47c7fa5df32b1690d67ae4352a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKAFKA__API_1_1KafkaClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKAFKA__API_1_1KafkaClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classKAFKA__API_1_1KafkaClient.html">KAFKA_API::KafkaClient</a></td></tr>
<tr class="memitem:a5805d4319254f3029b673c8bb9dd23e3 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a5805d4319254f3029b673c8bb9dd23e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KafkaClient</b> (ClientType clientType, const <a class="el" href="classKAFKA__API_1_1Properties.html">Properties</a> &amp;<a class="el" href="classKAFKA__API_1_1KafkaClient.html#a79f54433b395e4e306a11bb10be53e28">properties</a>, const ConfigCallbacksRegister &amp;registerCallbacks=ConfigCallbacksRegister(), const std::set&lt; std::string &gt; &amp;privatePropertyKeys={})</td></tr>
<tr class="separator:a5805d4319254f3029b673c8bb9dd23e3 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4691ad28928c2077de2f2eefc0bec4 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a0f4691ad28928c2077de2f2eefc0bec4"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>clientId</b> () const</td></tr>
<tr class="separator:a0f4691ad28928c2077de2f2eefc0bec4 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5b798d26194dbcb8812b5e180076c inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a81e5b798d26194dbcb8812b5e180076c"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const</td></tr>
<tr class="separator:a81e5b798d26194dbcb8812b5e180076c inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088143b9687f9e27075a1b2bff5c34f2 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a088143b9687f9e27075a1b2bff5c34f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#a088143b9687f9e27075a1b2bff5c34f2">setLogger</a> (Logger logger)</td></tr>
<tr class="memdesc:a088143b9687f9e27075a1b2bff5c34f2 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the log callback for the kafka client (it's a per-client setting). <br /></td></tr>
<tr class="separator:a088143b9687f9e27075a1b2bff5c34f2 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547ee00891d12ad42a0fb3b8ca1b61b4 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a547ee00891d12ad42a0fb3b8ca1b61b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#a547ee00891d12ad42a0fb3b8ca1b61b4">setLogLevel</a> (int level)</td></tr>
<tr class="memdesc:a547ee00891d12ad42a0fb3b8ca1b61b4 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log level for the kafka client (the default value: LOG_NOTICE). <br /></td></tr>
<tr class="separator:a547ee00891d12ad42a0fb3b8ca1b61b4 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678613fd893859387ce96b6f0a77d608 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#a678613fd893859387ce96b6f0a77d608">setStatsCallback</a> (StatsCallback cb)</td></tr>
<tr class="memdesc:a678613fd893859387ce96b6f0a77d608 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback to receive the periodic statistics info.  <a href="classKAFKA__API_1_1KafkaClient.html#a678613fd893859387ce96b6f0a77d608">More...</a><br /></td></tr>
<tr class="separator:a678613fd893859387ce96b6f0a77d608 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f54433b395e4e306a11bb10be53e28 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a79f54433b395e4e306a11bb10be53e28"></a>
const <a class="el" href="classKAFKA__API_1_1Properties.html">Properties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#a79f54433b395e4e306a11bb10be53e28">properties</a> () const</td></tr>
<tr class="memdesc:a79f54433b395e4e306a11bb10be53e28 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the properties which took effect. <br /></td></tr>
<tr class="separator:a79f54433b395e4e306a11bb10be53e28 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7ea0e2f4e1a321866e6f7ec1abc70e inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a4a7ea0e2f4e1a321866e6f7ec1abc70e"></a>
Optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#a4a7ea0e2f4e1a321866e6f7ec1abc70e">getProperty</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a4a7ea0e2f4e1a321866e6f7ec1abc70e inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the effected property (including the property internally set by librdkafka). <br /></td></tr>
<tr class="separator:a4a7ea0e2f4e1a321866e6f7ec1abc70e inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e46aad5007f3fe95800cb3b8d3c73 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="aad7e46aad5007f3fe95800cb3b8d3c73"></a>
Optional&lt; <a class="el" href="structKAFKA__API_1_1BrokerMetadata.html">BrokerMetadata</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#aad7e46aad5007f3fe95800cb3b8d3c73">fetchBrokerMetadata</a> (const std::string &amp;topic, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_METADATA_TIMEOUT_MS), bool disableErrorLogging=false)</td></tr>
<tr class="memdesc:aad7e46aad5007f3fe95800cb3b8d3c73 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch matadata from a available broker. <br /></td></tr>
<tr class="separator:aad7e46aad5007f3fe95800cb3b8d3c73 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec3e648a9704aaa204460e3c5a9caaf inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memTemplParams" colspan="2"><a id="acec3e648a9704aaa204460e3c5a9caaf"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:acec3e648a9704aaa204460e3c5a9caaf inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>doLog</b> (int level, const char *filename, int lineno, const char *format, Args... args) const</td></tr>
<tr class="separator:acec3e648a9704aaa204460e3c5a9caaf inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2cfe3fc9408ad802ea8fa8e2ff5386 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a9d2cfe3fc9408ad802ea8fa8e2ff5386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>doLog</b> (int level, const char *filename, int lineno, const char *msg) const</td></tr>
<tr class="separator:a9d2cfe3fc9408ad802ea8fa8e2ff5386 inherit pub_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classKAFKA__API_1_1KafkaClient"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classKAFKA__API_1_1KafkaClient')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classKAFKA__API_1_1KafkaClient.html">KAFKA_API::KafkaClient</a></td></tr>
<tr class="memitem:ae735fbad46953a0c5b57e40d810a3450 inherit pub_types_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="ae735fbad46953a0c5b57e40d810a3450"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EventsPollingOption</b> { <b>Manual</b>, 
<b>Auto</b>
 }</td></tr>
<tr class="separator:ae735fbad46953a0c5b57e40d810a3450 inherit pub_types_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classKAFKA__API_1_1KafkaClient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classKAFKA__API_1_1KafkaClient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classKAFKA__API_1_1KafkaClient.html">KAFKA_API::KafkaClient</a></td></tr>
<tr class="memitem:a37f4a7c1bca7144ff1444e9e975214ab inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a37f4a7c1bca7144ff1444e9e975214ab"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1KafkaClient.html#a37f4a7c1bca7144ff1444e9e975214ab">setGlobalLogger</a> (Logger logger=NoneLogger)</td></tr>
<tr class="memdesc:a37f4a7c1bca7144ff1444e9e975214ab inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a log callback for kafka clients, which do not have a client specific logging callback configured (see <code>setLogger</code>). <br /></td></tr>
<tr class="separator:a37f4a7c1bca7144ff1444e9e975214ab inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08805eb9e2b93c42598c4b98ecc971a inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memTemplParams" colspan="2"><a id="ac08805eb9e2b93c42598c4b98ecc971a"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:ac08805eb9e2b93c42598c4b98ecc971a inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>doGlobalLog</b> (int level, const char *filename, int lineno, const char *format, Args... args)</td></tr>
<tr class="separator:ac08805eb9e2b93c42598c4b98ecc971a inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f12df50cd662eb7770cd099d65a6f6b inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a3f12df50cd662eb7770cd099d65a6f6b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>doGlobalLog</b> (int level, const char *filename, int lineno, const char *msg)</td></tr>
<tr class="separator:a3f12df50cd662eb7770cd099d65a6f6b inherit pub_static_methods_classKAFKA__API_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for <a class="el" href="classKAFKA__API_1_1KafkaAutoCommitConsumer.html" title="Automatic-Commit consumer.">KafkaAutoCommitConsumer</a> and <a class="el" href="classKAFKA__API_1_1KafkaManualCommitConsumer.html" title="Manual-Commit consumer.">KafkaManualCommitConsumer</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab59ed5d3f932dc969a65850728e18121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59ed5d3f932dc969a65850728e18121">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::assign </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually assign a list of partitions to this consumer. </p>
<p>An exception would be thrown if subscribe is called previously (without a subsequent call to <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#aecd9af9255f51ec89d5ab3474c00d917" title="Unsubscribe from topics currently subscribed.">unsubscribe()</a>) </p>

</div>
</div>
<a id="abc7682cac64a49e7f0f26d9b8f27ce8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7682cac64a49e7f0f26d9b8f27ce8e">&#9670;&nbsp;</a></span>beginningOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;TopicPartition, Offset&gt; KAFKA_API::KafkaConsumer::beginningOffsets </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first offset for the given partitions. </p>
<p>This method does not change the current consumer position of the partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__FAIL: Generic failure </li>
</ul>

</div>
</div>
<a id="a14609c04b0bfd9df0f19cfef24428829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14609c04b0bfd9df0f19cfef24428829">&#9670;&nbsp;</a></span>committed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Offset KAFKA_API::KafkaConsumer::committed </td>
          <td>(</td>
          <td class="paramtype">const TopicPartition &amp;&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last committed offset for the given partition (whether the commit happened by this process or another).This offset will be used as the position for the consumer in the event of a failure. </p>
<p>This call will block to do a remote call to get the latest committed offsets from the server. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__INVALID_ARG: Invalid partition </li>
</ul>

</div>
</div>
<a id="a124721b254ba152f54d30b759f2509b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124721b254ba152f54d30b759f2509b6">&#9670;&nbsp;</a></span>endOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;TopicPartition, Offset&gt; KAFKA_API::KafkaConsumer::endOffsets </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last offset for the given partitions. </p>
<p>The last offset of a partition is the offset of the upcoming message, i.e. the offset of the last available message + 1. This method does not change the current consumer position of the partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__FAIL: Generic failure </li>
</ul>

</div>
</div>
<a id="ad4f7285339e8db1bdf65890627c7e041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f7285339e8db1bdf65890627c7e041">&#9670;&nbsp;</a></span>offsetsForTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; TopicPartition, Offset &gt; KAFKA_API::KafkaConsumer::offsetsForTime </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_QUERY_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offsets for the given partitions by time-point. </p>
<p>Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Not all offsets could be fetched in time.</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: All partitions are unknown.</li>
<li>RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE: Unable to query leaders from the given partitions. </li>
</ul>

</div>
</div>
<a id="abda00953ed830f8cd2a59ba1d9791036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda00953ed830f8cd2a59ba1d9791036">&#9670;&nbsp;</a></span>pause() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend fetching from all assigned partitions. </p>
<p>Future calls to <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will not return any records until they have been resumed using <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#ae365a263305dc74ffec2b4aed89aac59" title="Resume all partitions which have been paused with pause().">resume()</a>. Note: This method does not affect partition subscription/assignment. </p>

</div>
</div>
<a id="afcffc0a2eb517a1c2ac6aef7dd468ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcffc0a2eb517a1c2ac6aef7dd468ac3">&#9670;&nbsp;</a></span>pause() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::pause </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend fetching from the requested partitions. </p>
<p>Future calls to <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will not return any records from these partitions until they have been resumed using <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#ae365a263305dc74ffec2b4aed89aac59" title="Resume all partitions which have been paused with pause().">resume()</a>. Note: 1) After pausing, the application still need to call <code><a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a></code> at regular intervals. 2) This method does not affect partition subscription/assignment (i.e, pause fetching from partitions would not trigger a rebalance, since the consumer is still alive). 3) If none of the provided partitions is assigned to this consumer, an exception would be thrown. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with error:</p><ul>
<li>RD_KAFKA_RESP_ERR__INVALID_ARG: Invalid arguments </li>
</ul>

</div>
</div>
<a id="af2cf4c8f017064009d960c3a7a414ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cf4c8f017064009d960c3a7a414ff6">&#9670;&nbsp;</a></span>poll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classKAFKA__API_1_1ConsumerRecord.html">ConsumerRecord</a> &gt; KAFKA_API::KafkaConsumer::poll </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch data for the topics or partitions specified using one of the subscribe/assign APIs. </p>
<p>Returns the polled records. Note: 1) The result could be fetched through <a class="el" href="classKAFKA__API_1_1ConsumerRecord.html" title="A key/value pair to be received from Kafka.">ConsumerRecord</a> (with member function <code>error</code>). 2) Make sure the <code><a class="el" href="classKAFKA__API_1_1ConsumerRecord.html" title="A key/value pair to be received from Kafka.">ConsumerRecord</a></code> be destructed before the <code>KafkaConsumer.close()</code>. </p>

</div>
</div>
<a id="a05de75ea64ca1b706c4d48674cfb450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05de75ea64ca1b706c4d48674cfb450c">&#9670;&nbsp;</a></span>poll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t KAFKA_API::KafkaConsumer::poll </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classKAFKA__API_1_1ConsumerRecord.html">ConsumerRecord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch data for the topics or partitions specified using one of the subscribe/assign APIs. </p>
<p>Returns the number of polled records (which have been saved into parameter <code>output</code>). Note: 1) The result could be fetched through <a class="el" href="classKAFKA__API_1_1ConsumerRecord.html" title="A key/value pair to be received from Kafka.">ConsumerRecord</a> (with member function <code>error</code>). 2) Make sure the <code><a class="el" href="classKAFKA__API_1_1ConsumerRecord.html" title="A key/value pair to be received from Kafka.">ConsumerRecord</a></code> be destructed before the <code>KafkaConsumer.close()</code>. </p>

</div>
</div>
<a id="ae365a263305dc74ffec2b4aed89aac59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae365a263305dc74ffec2b4aed89aac59">&#9670;&nbsp;</a></span>resume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume all partitions which have been paused with <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abda00953ed830f8cd2a59ba1d9791036" title="Suspend fetching from all assigned partitions.">pause()</a>. </p>
<p>New calls to <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will return records from these partitions if there are any to be fetched. </p>

</div>
</div>
<a id="a929031b982dd494a7e2b1ed2252709e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929031b982dd494a7e2b1ed2252709e0">&#9670;&nbsp;</a></span>resume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::resume </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume specified partitions which have been paused with <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#abda00953ed830f8cd2a59ba1d9791036" title="Suspend fetching from all assigned partitions.">pause()</a>. </p>
<p>New calls to <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will return records from these partitions if there are any to be fetched. Note: If the partitions were not previously paused, this method is a no-op. </p>

</div>
</div>
<a id="a6674ebc4fcf57cbac3a9ab9842b7e916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6674ebc4fcf57cbac3a9ab9842b7e916">&#9670;&nbsp;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::seek </td>
          <td>(</td>
          <td class="paramtype">const TopicPartition &amp;&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Offset&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the fetch offsets that the consumer will use on the next poll(timeout). </p>
<p>If this API is invoked for the same partition more than once, the latest offset will be used on the next <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#af2cf4c8f017064009d960c3a7a414ff6" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a>. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Operation timed out</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: Invalid partition</li>
<li>RD_KAFKA_RESP_ERR__STATE: Invalid broker state </li>
</ul>

</div>
</div>
<a id="abfc05b7d4f95e37099e12fb5d3593a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc05b7d4f95e37099e12fb5d3593a9d">&#9670;&nbsp;</a></span>seekToBeginning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::seekToBeginning </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to the first offset for each of the given partitions. </p>
<p>This function evaluates lazily, seeking to the first offset in all partitions only when poll(long) or position(TopicPartition) are called. If no partitions are provided, seek to the first offset for all of the currently assigned partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Operation timed out</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: Invalid partition</li>
<li>RD_KAFKA_RESP_ERR__STATE: Invalid broker state </li>
</ul>

</div>
</div>
<a id="a7d399ab22eb97449a685f2ff6b870bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d399ab22eb97449a685f2ff6b870bdf">&#9670;&nbsp;</a></span>seekToEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::seekToEnd </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>tps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to the last offset for each of the given partitions. </p>
<p>This function evaluates lazily, seeking to the final offset in all partitions only when poll(long) or position(TopicPartition) are called. If no partitions are provided, seek to the first offset for all of the currently assigned partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Operation timed out</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: Invalid partition</li>
<li>RD_KAFKA_RESP_ERR__STATE: Invalid broker state </li>
</ul>

</div>
</div>
<a id="af29bf8f7f04b19fb67458f1bfa6336a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29bf8f7f04b19fb67458f1bfa6336a1">&#9670;&nbsp;</a></span>setGroupId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::setGroupId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To set group ID. </p>
<p>The group ID is mandatory for a Consumer. </p>

</div>
</div>
<a id="aa70f4ce12e2fa5fee7b07ace913eb1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70f4ce12e2fa5fee7b07ace913eb1b3">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::KafkaConsumer::subscribe </td>
          <td>(</td>
          <td class="paramtype">const Topics &amp;&#160;</td>
          <td class="paramname"><em>topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Consumer::RebalanceCallback&#160;</td>
          <td class="paramname"><em>cb</em> = <code>Consumer::RebalanceCallback()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe to the given list of topics to get dynamically assigned partitions. </p>
<p>An exception would be thrown if assign is called previously (without a subsequent call to <a class="el" href="classKAFKA__API_1_1KafkaConsumer.html#aecd9af9255f51ec89d5ab3474c00d917" title="Unsubscribe from topics currently subscribed.">unsubscribe()</a>) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/modern-cpp-kafka/modern-cpp-kafka/include/kafka/<a class="el" href="KafkaConsumer_8h_source.html">KafkaConsumer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
